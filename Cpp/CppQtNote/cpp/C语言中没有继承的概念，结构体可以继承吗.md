在 C 语言里，**既没有“类”，也没有“继承”这两个概念**。  
结构体（`struct`）只是“把若干成员打包在一起”的一块连续内存，编译器不会为它生成任何面向对象的元信息，也不会做名字查找、多态、权限控制等 OO 特性。因此：

1. 语法上不存在 `struct A : B { … };` 这种写法。  
	1. 语义上也不存在“子结构体是父结构体的一种”这种关系；所有成员只能靠你手工放在里面。

不过，**“组合”**（composition）是允许的，而且常被用来**“模拟”**继承。最常见的手法是：

```c
/* 父“类” */
struct Base {
    int x;
    void (*virt_print)(struct Base *);
};

/* 子“类” */
struct Derived {
    struct Base _base;   /* 必须放在第一个位置 */
    int y;
};

/* 使用 */
void derived_print(struct Base *b)
{
    /* 把 Base 指针强制转回 Derived */
    struct Derived *d = (struct Derived *)b;
    printf("x=%d y=%d\n", d->_base.x, d->y);
}

int main(void)
{
    struct Derived d = { {42, derived_print}, 99 };
    d._base.virt_print(&d._base);   /* 输出 x=42 y=99 */
}
```

只要 `_base` 放在派生结构体的**首地址**，`&d` 和 `&d._base` 的地址值相同，于是  
`(struct Base *)&d` 这个强制转换是安全的，C 标准保证可以访问 `_base` 里的成员。  
这就能“假装”成继承：  
- 把基类嵌进去 → 获得它的所有字段；  
- 把基类指针指向派生对象 → 可以统一处理不同“子类”；  
- 手动填函数指针 → 模拟虚函数/多态。

但请记住：  
- 这只是**程序员自己约定的编码技巧**，编译器不会帮你检查类型，也不会自动生成构造、析构、重载等。  
- 如果 `_base` 不放在第一个位置，或者你把任意指针乱转，就可能出现未定义行为。  
- 想要真正的继承、多态、访问控制，请用 C++、Rust、Go 等自带 OO 或接口机制的语言。

一句话总结：  
**C 的结构体本身不会继承；你只能通过“把父结构体嵌到子结构体里”这种组合方式，手工模拟继承的效果。**