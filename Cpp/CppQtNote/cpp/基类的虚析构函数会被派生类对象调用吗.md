会，而且**必须会**；  
**只要基类析构函数是 `virtual`，当通过基类指针/引用删除派生类对象时，**  
**先调用派生类析构函数，再沿着继承链自下而上依次调用各基类析构函数**，  
从而保证资源被完整地释放。

---

### 1. 为什么需要虚析构函数？

如果基类析构函数**不是虚函数**：

```cpp
struct Base { ~Base() { std::cout << "~Base\n"; } };
struct Derived : Base { ~Derived() { std::cout << "~Derived\n"; } };

Base* p = new Derived;
delete p;          // 仅输出 ~Base，Derived 部分泄漏/未清理
```

- 结果：**未定义行为**（UB），只执行 `Base::~Base`，派生部分没机会析构。  
- 典型后果：内存泄漏、资源泄漏、RAII 对象未正确释放。

---

### 2. 把析构函数声明为 `virtual`

```cpp
struct Base {
    virtual ~Base() { std::cout << "~Base\n"; }
};

struct Derived : Base {
    ~Derived() override { std::cout << "~Derived\n"; }
};

Base* p = new Derived;
delete p;
```

**输出顺序：**

```
~Derived
~Base
```

- 派生类析构函数先执行（释放派生资源）。  
- 然后自动调用基类析构函数（释放基类资源）。  
- 整个链条由编译器生成，**不需要手动 `~Derived()` 里再调 `Base::~Base()`**。

---

### 3. 纯虚析构函数也可以

```cpp
struct Base {
    virtual ~Base() = 0;   // 纯虚析构
};

inline Base::~Base() {}    // 必须在类外提供定义

struct Derived : Base { ~Derived() { std::cout << "~Derived\n"; } };
```

- 抽象类仍然需要析构函数的实现，否则链接失败。  
- 其他规则与上面完全相同。

---

### 4. 一句话结论

> **“基类虚析构函数是派生类对象被正确销毁的‘保险丝’；没有它，`delete` 基类指针将产生未定义行为。”**

