一句话：  
**当你需要“把一份即将消亡的临时资源安全地转移给别人”时，就使用右值（或右值引用）。**

---

### 1. 必须出现右值 / 右值引用的典型场景

| 场景 | 使用形式 | 目的 |
|---|---|---|
| **实现或调用移动构造/移动赋值** | `T(T&&)`, `T& operator=(T&&)` | 避免深拷贝，直接“偷”资源 |
| **实现完美转发** | `template<class T> void f(T&& x) { g(std::forward<T>(x)); }` | 保持值类别不变 |
| **把命名对象显式标记为“可移动”** | `std::move(obj)` | 触发重载决议中的 `&&` 版本 |
| **接收即将销毁的临时量** | `void sink(std::string&& s);` | 临时量作为右值传进来 |

---

### 2. 快速判断口诀

- **临时量**（纯右值）：`getVector()`、`42`、`std::string("tmp")`  
- **将亡值**（xvalue）：`std::move(obj)`、返回 `T&&` 的表达式  
→ 这两种都“寿命短”，最适合右值引用去“接管”。

---

### 3. 反例：什么时候**不要**用右值

| 错误示例 | 原因 |
|---|---|
| `const std::string&& s = str;` | `const` 右值引用只能读，不能移动 |
| `std::move(const_obj)` | `const` 导致最终仍走拷贝 |
| `auto&& v = vec;` 误当移动 | `auto&&` 只是万能引用，并不移动 |

---

### 4. 一句话记忆

> **“右值/右值引用只在‘资源搬家’或‘完美转发’时登场；其余场景用左值引用即可。”**