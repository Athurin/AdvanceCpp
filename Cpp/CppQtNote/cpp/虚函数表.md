虚函数表（vtable）一句话定义：  
**“每个带虚函数的类在编译期生成的一张静态函数指针数组，对象里藏一个指向它的隐藏指针 vptr，运行时靠 vptr[vindex] 完成动态分派。”**

---

### 1. 对象里到底多了什么？

```cpp
struct A { virtual void f(); int x; };
```

- 32/64 位环境：对象大小 = `sizeof(void*) + sizeof(int)`  
  ‑ 多出的 `void*` 就是 **vptr**（放在最前面，布局由 ABI 规定）。  
- 没有虚函数就没有 vptr，也就没有运行时多态。

---

### 2. vtable 长什么样？

```cpp
struct A {
    virtual void f1();
    virtual void f2();
    void g();          // 非虚，不进表
};

struct B : A {
    void f1() override;
    virtual void f3();
};
```

**内存示意：**

```
A::vtable[2]   = { &A::f1, &A::f2 }      // 只读，全局唯一
B::vtable[3]   = { &B::f1, &A::f2, &B::f3 } // 覆盖的槽填新地址
```

- 槽位顺序 = 虚函数在类中**声明次序**。  
- 纯虚函数 `=0` 的槽填 `__cxa_pure_virtual` 之类占位函数，使抽象类不能实例化。  
- 一个类一张表，所有该类的对象共享同一张表。

---

### 3. 一次虚调用的完整流程（x86-64 psABI）

```cpp
A* p = new B;
p->f1();
```

汇编伪码：

```
mov rax, [p]          ; rax = vptr
call [rax]            ; 跳转到 *vtable[0] = &B::f1
```

- 只有 **一次额外内存读取 + 一次间接调用**，开销固定。  
- 现代 CPU 对 vtable 跳转分支预测良好，通常 <5 ns。

---

### 4. 多重继承 & 虚继承

| 场景 | vtable/vptr 数量 | 特殊处理 |
|---|---|---|
| 单继承 | 1 个 vptr | 简单覆盖 |
| 多重继承 | **每个基类各 1 个 vptr** | this 指针需调整（thunk） |
| 虚继承 | 再加 **vbase table** 存偏移 | 菱形继承中共享基类子对象 |

示例：

```cpp
struct A { virtual void fa(); };
struct B { virtual void fb(); };
struct C : A, B { void fa() override; };

// C 对象里两个 vptr：
// - vptr_A → {&C::fa, ...}
// - vptr_B → {&B::fb, ...}
```

---

### 5. 常见疑问 FAQ

| 问题 | 回答 |
|---|---|
| 构造函数里能调用虚函数吗？ | **可以，但只会静态绑定到当前类版本**。对象尚未完成派生部分构造。 |
| 析构函数里能调用虚函数吗？ | 可以，同样静态绑定。 |
| 静态成员函数能是虚函数吗？ | **不能**，静态函数无 this，不存在动态分派。 |
| 内联虚函数会怎样？ | 编译器仍生成 out-of-line 实体以供 vtable 指向；调用点可内联但 vtable 槽不变。 |
| 能手动改 vtable 吗？ | 标准禁止；但底层调试器/黑科技可做（UB）。 |

---

### 6. 验证工具（Linux）

- 查看 vtable 符号：`nm -C a.out | grep vtable`  
- 查看对象布局：`clang -Xclang -fdump-record-layouts -std=c++20 a.cpp`

---

### 7. 一句话背诵

> **“编译期建表，对象藏指针，运行期查表跳函数——这就是 C++ 虚函数表。”**