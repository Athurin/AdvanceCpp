例：
```cpp
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int array[10] = {2,1,65,23,12,0,53,2,5,4};

    printf("array:  %p\n", (void*)array);
    printf("&array: %p\n", (void*)&array);

    printf("array+1:  %p\n", (void*)(array+1));
    printf("&array+1: %p\n", (void*)(&array+1));

    printf("sizeof(array):   %zu\n", sizeof(array));
    printf("sizeof(&array):  %zu\n", sizeof(&array));

    system("pause");
    return 0;
}
```
64位系统输出：
```bash
array:  000000BBD3F2F778
&array: 000000BBD3F2F778
array+1:  000000BBD3F2F77C
&array+1: 000000BBD3F2F7A0
sizeof(array):   40
sizeof(&array):  8
请按任意键继续. . .
```

把代码先改成**64 位下能编译通过且结果清晰**的版本（原句有拼写错、格式符不严谨）：

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int array[10] = {2,1,65,23,12,0,53,2,5,4};

    printf("array:  %p\n", (void*)array);
    printf("&array: %p\n", (void*)&array);

    printf("array+1:  %p\n", (void*)(array+1));
    printf("&array+1: %p\n", (void*)(&array+1));

    printf("sizeof(array):   %zu\n", sizeof(array));
    printf("sizeof(&array):  %zu\n", sizeof(&array));

    system("pause");
    return 0;
}
```

--------------------------------------------------
运行结果（典型 64 bit，地址仅作示例）：

```
array:   00000061fb7ff7c0
&array:  00000061fb7ff7c0
array+1: 00000061fb7ff7c4
&array+1:00000061fb7ff7e8
sizeof(array):   40
sizeof(&array):  8
```

--------------------------------------------------
逐句解释

1. `array` vs `&array`  
   - **值相同**：都给出数组首元素所在字节的地址。  
   - **类型不同**：  
     - `array` 在表达式里会**退化**为 `int*`（指向首元素）。  
     - `&array` 是“整个数组的地址”，类型为 `int (*)[10]`。

2. `array+1` vs `&array+1`  
   - `array+1` 是“首元素地址 + 1 个 `int` 步长”，所以 +4 字节（32 位 +4，64 位也是 +4，因为 `int` 仍是 4 B）。  
   - `&array+1` 是“整个数组地址 + 1 个 `int[10]` 步长”，即 +40 字节。

3. `sizeof(array)`  
   - 数组本身大小：10 × `sizeof(int)` = 40。

4. `sizeof(&array)`  
   - 取的是“指向整个数组的指针”大小，即普通指针大小，在 64 位平台为 8 字节。

--------------------------------------------------
一句话总结  
**地址值相同，步长看类型；`sizeof` 数组得总字节，`sizeof` 指针只得地址宽。**

# array本质上是一个指针，指向数组的首地址，为什么&array，取地址之后输出的是指针的内容，而不是指针变量所在的地址

这是最常见的误解，**一句话先打碎它**：

> `array` **不是**指针变量，它**就是数组本身**；只有在**大多数表达式**里才会**自动转换成首元素地址**。  
> 因此 `&array` 取的是“整个数组对象的地址”，而不是“某个指针变量的地址”——**因为根本不存在“某个指针变量**”。

--------------------------------------------------
拆开讲三遍，保你永不再混：

1. 定义层面  
   ```c
   int array[10];
   ```
   编译器只分配 10×4 字节**连续空间**，起名叫 `array`，**没有额外再分配一个指针变量**。  
   所以 `array` 不是变量，它是**数组对象的名字**。

2. 表达式层面（C 标准 6.3.2.1）  
   当数组名出现在 `+`、`-`、`[]`、`==`、函数参数等**大多数运算符**中时，编译器自动把它**转换**为  
   ```
   &array[0]   // 类型 int*
   ```
   这叫“**array-to-pointer decay**”（数组衰变）。  
   衰变后你拿到的是**首元素地址**，于是很多人误以为“数组就是指针”。

3. 取地址运算符 `&` 的例外  
   `&` 是**少数几个**不会让数组衰变的运算符之一（另一个是 `sizeof`）。  
   所以
   ```
   &array
   ```
   的类型是 `int (*)[10]`——**指向整个数组的指针**，值恰好等于首元素地址，但步长是整个数组大小。

--------------------------------------------------
脑图一句话  
**“数组不是指针，只是常常假装成指针；`&array` 取的是数组本尊的地址，不是某个并不存在的指针变量的地址。”**

