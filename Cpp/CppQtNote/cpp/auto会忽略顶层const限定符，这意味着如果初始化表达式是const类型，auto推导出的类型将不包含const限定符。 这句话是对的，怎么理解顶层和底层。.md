把 `const` 想象成一把“锁”，它有两种锁法：

1. **顶层（top-level）const**  
   锁的是“变量盒子**本身**”。  
   变量一经创建，这把锁就永远焊死在盒子上，**别人想再复制一个盒子，不会把锁也一起带走**。

   ```cpp
   const int ci = 42;   // ci 这个盒子被锁死，值不能再改
   int a = ci;          // a 得到 42，但 a 的盒子没上锁
   ```

   这里的 `const` 就是**顶层 const**：它修饰的是变量 `ci` 本身。  
   当 `auto` 进行“值拷贝”推导时，只关心“里面是什么”，不关心“原盒子是不是被锁死”，于是推导结果**丢弃**顶层 const：

   ```cpp
   auto x = ci;   // 推导为 int，不保留 const
   ```

2. **底层（low-level）const**  
   锁的是“盒子里的**指针/引用指向的东西**”。  
   复制盒子时，这把锁仍跟着内容走。

   ```cpp
   const char* p = "abc";   // p 盒子没锁，但 *p 的内容被锁
   auto q = p;              // q 的类型仍是 const char*
   ```

   这里的 `const` 修饰的是 `*p`，即“指针指向的字符序列”，属于**底层 const**。  
   拷贝指针时，这把锁必须保留，否则原对象的 const 语义就被破坏。

---

快速判断口诀  
- 如果 `const` 后面直接跟着**变量名**，那是**顶层 const**。  
  `const int ci` → 顶层 const。  
- 如果 `const` 后面先出现 `*` 或 `&`，再出现变量名，那是**底层 const**。  
  `const int* p` → 底层 const（锁的是 `*p`，不是 `p`）。

---

回到原句  
> “auto 会忽略顶层 const 限定符”

就是：  
当 `auto` 做**值拷贝**时，**原盒子上的锁不复制到新盒子**；  
但 **底层锁（内容锁）始终会保留**。