虚析构是为了 **“通过基类指针删除派生类对象时，仍然能够正确地调用到派生类的析构函数”**，从而 **“先析构派生、再析构基”**，保证资源不泄漏、程序不崩溃。

---

### ✅ 1. 先看成因——普通析构会“切层”
```cpp
class Base {               // 析构函数不是 virtual
public:
    ~Base() { cout << "~Base\n"; }
};

class Derived : public Base {
public:
    ~Derived() { cout << "~Derived\n"; }
};

Base* p = new Derived;
delete p;                  // 未定义行为（UB）：只执行 ~Base！
```
| 结果 | 问题 |
|------|------|
| **~Derived 不会被执行** | 派生类里管理的资源（内存、文件、锁）全部泄漏 |
| **C++ 标准 UB** | 可能直接 crash，也可能看似正常，但程序已病 |

---

### ✅ 2. 虚析构解决方案
```cpp
class Base {
public:
    virtual ~Base() { cout << "~Base\n"; }   // 关键：virtual
};

Base* p = new Derived;
delete p;                  // OK：先 ~Derived，再 ~Base
```
| 效果 | 说明 |
|------|------|
| **动态决议** | 运行时根据实际对象类型从 **最派生层开始逐级向上** 调析构 |
| **资源安全** | 派生类资源先被释放，基类资源后被释放，**无泄漏** |
| **兼容多态** | 与虚函数共用同一 vptr/vtable 机制，**零额外成本** |

---

### ✅ 3. 一条编译器生成的隐藏链
`delete p;` 实际展开：  
1. 调 `p->~Derived()`（用户代码）  
2. 调 `operator delete(p)`（释放内存）  
若基类析构非 virtual，第 1 步就 **找不到 Derived 析构地址**，只能调 Base 版本。

---

### ✅ 4. 使用场景口诀
> **“只要类可能被继承并且通过基类指针删除，就把析构函数声明为 virtual。”**  
更彻底：  
- **纯接口类** → `virtual ~Interface() = default;`  
- **纯接口且无需定义** → `virtual ~Interface() = 0;` （仍需提供函数体）

---

### ✅ 5. 现代 C++ 辅助
- `std::shared_ptr<Base> p = std::make_shared<Derived>();`  
  **控制块记录实际类型**，即使 Base 析构非 virtual，也能正确调用 ~Derived（**shared_ptr 的 Deleter 魔术**）。  
- 但 **unique_ptr 与普通裸指针仍需虚析构**；为了不依赖智能指针类型，**“基类虚析构”仍是最简契约**。

---

### ✅ 6. 面试一句话答法
> “当通过基类指针删除派生对象时，若析构函数非 virtual，只会静态调用基类版本，导致派生类资源泄漏；声明为 virtual 后，运行时从最远派生层开始逐级析构，**保证资源正确释放、行为安全**。”

