

### ✅ 1. 语言层面（核心意义）
> **允许同一个函数在多个翻译单元（.cpp）中重复定义而不违反 ODR（一次定义规则）**。  
> 链接器会把所有副本合并成同一个实体。

- **是否内联展开**（消除调用开销）只是**对编译器的建议**，它爱听不听。
- 现代编译器对“是否真正展开”几乎完全按优化策略决定，**跟你写不写 `inline` 基本无关**。

---

### ✅ 2. 性能层面（历史遗留印象）
早期编译器确实把 `inline` 当成“请你把代码展开到调用点”的提示，用来消除函数调用开销。  
今天这个用途已**退化**——编译器有 IPO/LTO、`-O3`、`-finline-functions` 等全局优化，**连巨大函数都敢展开**，也**敢拒绝展开你标了 `inline` 的小函数**。

---

### ✅ 什么时候必须写 `inline`
| 场景 | 理由 |
|------|------|
| **头文件中实现非模板函数** | 否则多个 `.cpp` 包含后会出现多重定义链接错误 |
| **类内定义的成员/友元函数** | 语言默认隐式 `inline`，无需手写 |
| **模板函数/模板类的成员定义** | 模板在多个翻译单元实例化，需要 `inline` 允许重复定义 |

---

### ❌ 什么时候**不能**写 `inline`
| 场景 | 原因 |
|------|------|
| **替换全局 `operator new`/`operator delete`** | `[replacement.functions]/3` 要求**用户提供的替换版本不能是内联函数**，否则不同翻译单元可能拥有不同副本，违反 ODR，链接器无法合并 |
| **需要取函数地址并保证唯一性** | 例如动态库导出符号、函数指针比较等；`inline` 可能导致每个单元生成不同地址 |

---

### ✅ 为什么模板定义通常带 `inline`
模板**定义**几乎总是放在头文件，且会在多个 `.cpp` 中被实例化出相同签名。  
`inline` 给予“重复定义合法”的许可，否则链接阶段会报多重定义。  
（模板本身不是 `inline`，但**头文件里的定义**通常加上 `inline` 或直接写在类内，借助隐式 `inline` 规避 ODR。）

---

### ✅ 一句话总结
- `inline` 的首要任务是**“让重复定义合法”**，不是“提速”。  
- 真正消除调用开销靠编译器优化，**不是你写 `inline`**。  
- 写不写 `inline` 取决于**“是否需要在头文件里放函数定义”**和**“是否允许重复符号”**；  
  替换全局 `operator new` 等**必须唯一**的函数就**不能 `inline`**。

